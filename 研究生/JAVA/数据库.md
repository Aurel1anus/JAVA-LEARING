## JDBC
什么是JDBC？JDBC是Java DataBase Connectivity的缩写，它是Java程序访问数据库的标准接口。
使用Java程序访问数据库时，Java代码并不是直接通过TCP连接去访问数据库，而是通过JDBC接口来访问，而JDBC接口则通过JDBC驱动来实现真正对数据库的访问。

==从代码来看，Java标准库自带的JDBC接口其实就是定义了一组接口，而某个具体的JDBC驱动其实就是实现了这些接口的类==

使用JDBC的好处是：

- 各数据库厂商使用相同的接口，Java代码不需要针对不同数据库分别开发；
- Java程序编译期仅依赖java.sql包，不依赖具体数据库的jar包；
- 可随时替换底层数据库，访问数据库的Java代码基本不变。

## 什么是SQL
什么是SQL？简单地说，SQL就是访问和处理关系数据库的计算机标准语言

### 关系模型
一对一，一对多，多对一
主键：某一个字段不重复，能够区分各个记录的字段（记录的主键不能相同）
联合主键：如无必要，不使用

### 外键：
外键来自外部的表，可以把数据与另一张表关联起来，这种列称为`外键`
```mysql
ALTER TABLE students
ADD CONSTRAINT fk_class_id
FOREIGN KEY (class_id)
REFERENCES classes (id);
```
其中，外键约束的名称`fk_class_id`可以任意，`FOREIGN KEY (class_id)`指定了`class_id`作为外键，`REFERENCES classes (id)`指定了这个外键将关联到`classes`表的`id`列（即`classes`表的主键）。


通过中间表，定义多对多、一对一关系

关系数据库通过外键可以实现一对多、多对多和一对一的关系。外键既可以通过数据库来约束，也可以不设置约束，仅依靠应用程序的逻辑来保证。

### 索引
索引是关系数据库中对某一列或多个列的值进行预排序的数据结构

==索引的效率取决于索引列的值是否散列，即该列的值如果越互不相同，那么索引效率越高。==
对于主键，关系数据库会自动对其创建主键索引。使用主键索引的效率是最高的，因为主键会保证绝对唯一。


## 数据库语法

```mysql
//基本查询
SELECT * FROM <表名>
//条件查询 通过`WHERE`条件来设定查询条件
SELECT * FROM students WHERE score >= 80;
SELECT * FROM <表名> WHERE <条件表达式>
SELECT * FROM students WHERE score >= 80 AND gender = 'M';
SELECT * FROM students WHERE score >= 80 OR gender = 'M';
SELECT * FROM students WHERE NOT class_id = 2;
-- 按多个条件查询students:
SELECT * FROM students WHERE (score < 80 OR score > 90) AND gender = 'M';
//投影查询
SELECT id, score, name FROM students;
-- 使用投影查询，并将列名重命名，讲score列重命名为points：
SELECT id, score points, name FROM students;
-- 使用投影查询+WHERE条件：
SELECT id, score points, name FROM students WHERE gender = 'M';
//排序 ORDER BY(从低到高，升序)， DESC（从高到低，降序）
-- 按score从低到高:
SELECT id, name, gender, score FROM students ORDER BY score;
-- 按score从高到低:
SELECT id, name, gender, score FROM students ORDER BY score DESC;
-- 按score, gender排序，先排score，score有相同的记录再根据gander排序:
SELECT id, name, gender, score FROM students ORDER BY score DESC, gender;
-- 带WHERE条件的ORDER BY，如果有`WHERE`子句，那么`ORDER BY`子句要放到`WHERE`子句后面:
SELECT id, name, gender, score
FROM students
WHERE class_id = 1
ORDER BY score DESC;
//分页查询 (LIMIT x OFFSET y)
-- 查询第1页，`LIMIT 3 OFFSET 0`表示，对结果集从0号记录开始，最多取3条:
SELECT id, name, gender, score
FROM students
ORDER BY score DESC
LIMIT 3 OFFSET 0;
-- LIMIT 3 OFFSET 3;查询第二页
-- LIMIT 3 OFFSET 6;查询第三页
-- LIMIT 3 OFFSET 9;查询第四页
-- LIMIT x 代表页面的最大数据条数， OFFSET y 代表从第y条数据记录开始截取
-- 可简写成 LIMIT x,y
//聚合查询  （COUNT,SUM,AVG,MAX,MIN）
SELECT COUNT(*) FROM students;-- `COUNT(*)`表示查询所有列的行数
-- 使用聚合查询并设置结果集的列名为num:
SELECT COUNT(*) num FROM students;
-- 使用聚合查询并设置WHERE条件:
SELECT COUNT(*) boys FROM students WHERE gender = 'M';
-- 除了`COUNT()`函数外，SQL还提供了如下聚合函数：
|函数|说明|
|---|---|
|SUM|计算某一列的合计值，该列必须为数值类型|
|AVG|计算某一列的平均值，该列必须为数值类型|
|MAX|计算某一列的最大值|
|MIN|计算某一列的最小值|
-- 使用聚合查询计算男生平均成绩:
SELECT AVG(score) average FROM students WHERE gender = 'M';
SELECT FLOOR(COUNT(*) / 3) FROM students;-- FLOOR 代表向下取整
SELECT CEILING(COUNT(*) / 3) FROM students;-- CEILING 代表向上取整
-- 应用场景： 如果我们要统计一班的学生数量，我们知道，可以用`SELECT COUNT(*) num FROM students WHERE class_id = 1;`。如果要继续统计二班、三班的学生数量，难道必须不断修改`WHERE`条件来执行`SELECT`语句吗？
-- 执行该`SELECT`语句时，会把`class_id`相同的列先分组，再分别计算，因此，得到了3行结果
-- 按class_id分组:
SELECT COUNT(*) num FROM students GROUP BY class_id;
-- 按class_id分组，结果带class_id:
SELECT class_id, COUNT(*) num FROM students GROUP BY class_id;
-- 按class_id, gender分组:结果会出现class_id, gender, num这三行，先把所有students表内的数据记录根据class_id分组，再根据gender分组，再计算count（*），*代表计算的是每个分组中的数据记录数
SELECT class_id, gender, COUNT(*) num FROM students GROUP BY class_id, gender;

//多表查询（笛卡尔积查询）
-- FROM students, classes:
-- 结果集的列数是`students`表和`classes`表的列数之和，行数是`students`表和`classes`表的行数之积。
-- ==笛卡尔查询==
SELECT * FROM students, classes;
-- 多表查询时，要使用`表名.列名`这样的方式来引用列和设置别名，这样就避免了结果集的列名重复问题
-- set alias:
SELECT
    students.id sid,
    students.name,
    students.gender,
    students.score,
    classes.id cid,
    classes.name cname
FROM students, classes;
-- 但是，用`表名.列名`这种方式列举两个表的所有列实在是很麻烦，所以SQL还允许给表设置一个别名，让我们在投影查询中引用起来稍微简洁一点
-- set table alias:
SELECT
    s.id sid,
    s.name,
    s.gender,
    s.score,
    c.id cid,
    c.name cname
FROM students s, classes c;

//连接查询（JOIN运算，只拼接另外一个表想用的列）
-- 选出所有学生，同时返回班级名称:
-- 内连接INNER JOIN
SELECT s.id, s.name, s.class_id, c.name class_name, s.gender, s.score
FROM students s
INNER JOIN classes c
ON s.class_id = c.id;
//
注意INNER JOIN查询的写法是：
1. 先确定主表，仍然使用`FROM <表1>`的语法；
2. 再确定需要连接的表，使用`INNER JOIN <表2>`的语法；
3. 然后确定连接条件，使用`ON <条件...>`，这里的条件是`s.class_id = c.id`，表示`students`表的`class_id`列与`classes`表的`id`列相同的行需要连接；
4. 可选：加上`WHERE`子句、`ORDER BY`等子句。
//
//
JOIN查询需要先确定主表，然后把另一个表的数据“附加”到结果集上；
INNER JOIN是最常用的一种JOIN查询，它的语法是`SELECT ... FROM <表1> INNER JOIN <表2> ON <条件...>`；
JOIN查询仍然可以使用`WHERE`条件和`ORDER BY`排序。
//
//修改数据（- INSERT - UPDATE - DELETE）
-- INSERT 语法（插入记录）
INSERT INTO <表名> (字段1, 字段2, ...) VALUES (值1, 值2, ...);
-- 可以一次性添加多条记录，只需要在`VALUES`子句中指定多个记录值，每个记录是由`(...)`包含的一组值，每组值用逗号`,`分隔
-- 一次性添加多条新记录:
INSERT INTO students (class_id, name, gender, score) VALUES
  (1, '大宝', 'M', 87),
  (2, '二宝', 'M', 81),
  (3, '三宝', 'M', 83);
-- UPDATE 语法（更新已有数据记录中的值）
UPDATE <表名> SET 字段1=值1, 字段2=值2, ... WHERE ...;
-- 在`UPDATE`语句中，更新字段时可以使用表达式
UPDATE students SET score=score+10 WHERE score<80;
-- `UPDATE`语句可以没有`WHERE`条件，这时，整个表的所有记录都会被更新。
UPDATE students SET score=60;
-- DELETE 语法
DELETE FROM <表名> WHERE ...;
-- 和`UPDATE`类似，不带`WHERE`条件的`DELETE`语句会删除整个表的数据
DELETE FROM students;
-- delete where 没找到具体数据，不会删除任何记录，和update一样。


```






### 四种内连接方式
![[Pasted image 20251012143147.png]]